<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Plot Digitizer</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
        }
        h1 {
            color: #333;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        .workflow-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }
        .tab {
            padding: 10px 20px;
            background: #f5f5f5;
            border: none;
            border-radius: 10px 10px 0 0;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }
        .tab.active {
            background: #667eea;
            color: white;
        }
        .tab-content {
            display: none;
            animation: fadeIn 0.3s;
        }
        .tab-content.active {
            display: block;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .controls {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .control-group {
            margin: 15px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .control-group label {
            min-width: 150px;
            font-weight: 600;
            color: #555;
        }
        input[type="range"] {
            width: 200px;
            height: 6px;
            background: #ddd;
            border-radius: 3px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            width: 18px;
            height: 18px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
        }
        input[type="number"], input[type="date"], input[type="text"] {
            padding: 8px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        input[type="number"]:focus, input[type="date"]:focus, input[type="text"]:focus {
            border-color: #667eea;
            outline: none;
        }
        input[type="color"] {
            width: 50px;
            height: 40px;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
            cursor: pointer;
        }
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            margin: 5px;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        button:active {
            transform: translateY(0);
        }
        button.secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        button.success {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
        }
        .canvas-container {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .canvas-wrapper {
            flex: 1;
            min-width: 400px;
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        .canvas-wrapper h3 {
            margin-top: 0;
            color: #667eea;
        }
        canvas {
            max-width: 100%;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
            display: block;
            cursor: crosshair;
        }
        #digitizedCanvas {
            cursor: pointer;
        }
        .info-box {
            background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #667eea;
        }
        .status {
            margin: 10px 0;
            padding: 12px;
            border-radius: 5px;
            display: none;
            font-weight: 500;
        }
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
            display: block;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            display: block;
        }
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
            display: block;
        }
        .data-preview {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            max-height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 10px;
            border-radius: 10px;
            text-align: center;
        }
        .stat-card .value {
            font-size: 24px;
            font-weight: bold;
        }
        .stat-card .label {
            font-size: 12px;
            opacity: 0.9;
        }
        .manual-points {
            max-height: 200px;
            overflow-y: auto;
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .manual-point {
            display: flex;
            justify-content: space-between;
            padding: 5px;
            border-bottom: 1px solid #e0e0e0;
        }
        .manual-point:hover {
            background: #e3f2fd;
        }
        .remove-point {
            color: #f5576c;
            cursor: pointer;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìä Interactive Plot Digitizer with Noise Removal</h1>
        
        <div class="workflow-tabs">
            <button class="tab active" onclick="switchTab('noise')">Step 1: Noise Removal</button>
            <button class="tab" onclick="switchTab('calibration')">Step 2: Calibration</button>
            <button class="tab" onclick="switchTab('digitization')">Step 3: Digitization</button>
            <button class="tab" onclick="switchTab('export')">Step 4: Export</button>
        </div>

        <!-- Step 1: Noise Removal -->
        <div id="noise-tab" class="tab-content active">
            <div class="info-box">
                <strong>üéØ Step 1: Remove Noise</strong><br>
                Upload your plot image and adjust settings to isolate the data line by removing noise and unwanted elements.
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Upload Image:</label>
                    <input type="file" id="fileInput" accept="image/*">
                </div>
                
                <div class="control-group">
                    <label>Target Color:</label>
                    <input type="color" id="targetColor" value="#4472c4">
                    <input type="text" id="colorHex" value="#4472c4" placeholder="#000000">
                    <button onclick="pickColor()" class="secondary" style="padding: 8px 16px;">Pick from Image</button>
                </div>
                
                <div class="control-group">
                    <label>Color Tolerance:</label>
                    <input type="range" id="tolerance" min="0" max="100" value="30">
                    <span id="toleranceValue">30</span>
                </div>
                
                <div class="control-group">
                    <label>Min Cluster Size:</label>
                    <input type="range" id="minCluster" min="1" max="20" value="3">
                    <span id="minClusterValue">3</span>
                </div>
                
                <div class="control-group">
                    <button onclick="processNoise()">Remove Noise</button>
                    <button onclick="resetNoise()" class="secondary">Reset</button>
                </div>
            </div>

            <div class="canvas-container">
                <div class="canvas-wrapper">
                    <h3>Original Image</h3>
                    <canvas id="originalCanvas"></canvas>
                </div>
                <div class="canvas-wrapper">
                    <h3>Noise Removed</h3>
                    <canvas id="cleanedCanvas"></canvas>
                </div>
            </div>
        </div>

        <!-- Step 2: Calibration -->
        <div id="calibration-tab" class="tab-content">
            <div class="info-box">
                <strong>üìè Step 2: Set Axes Calibration</strong><br>
                Define the coordinate system by setting axis limits and data ranges. For time series, specify the date range.
            </div>

            <div class="controls">
                <h4>Y-Axis Range</h4>
                <div class="control-group">
                    <label>Y Minimum:</label>
                    <input type="number" id="yMin" value="-50" step="any">
                </div>
                <div class="control-group">
                    <label>Y Maximum:</label>
                    <input type="number" id="yMax" value="210" step="any">
                </div>
                
                <h4>X-Axis Range (Time Series)</h4>
                <div class="control-group">
                    <label>Start Date:</label>
                    <input type="date" id="startDate" value="2019-01-01">
                </div>
                <div class="control-group">
                    <label>End Date:</label>
                    <input type="date" id="endDate" value="2024-12-31">
                </div>
                <div class="control-group">
                    <label>Interval:</label>
                    <select id="interval">
                        <option value="day">Daily</option>
                        <option value="week" selected>Weekly</option>
                        <option value="month">Monthly</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <button onclick="applyCalibration()" class="success">Apply Calibration</button>
                </div>
            </div>
        </div>

        <!-- Step 3: Digitization -->
        <div id="digitization-tab" class="tab-content">
            <div class="info-box">
                <strong>‚ú® Step 3: Extract Data Points</strong><br>
                The tool will automatically detect data points. You can also manually add or correct points by clicking on the image.
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Detection Method:</label>
                    <select id="detectionMethod">
                        <option value="auto">Automatic</option>
                        <option value="semi">Semi-Automatic</option>
                        <option value="manual">Manual Only</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>Smoothing:</label>
                    <input type="range" id="smoothing" min="0" max="10" value="3">
                    <span id="smoothingValue">3</span>
                </div>
                
                <div class="control-group">
                    <button onclick="digitizeData()">Auto-Digitize</button>
                    <button onclick="clearPoints()" class="secondary">Clear Points</button>
                    <button onclick="interpolateGaps()" class="secondary">Fill Gaps</button>
                </div>
                
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="manualMode"> Enable Manual Point Addition (click on plot)
                    </label>
                </div>
            </div>

            <div class="stats-grid">
                <div class="stat-card">
                    <div class="value" id="pointCount">0</div>
                    <div class="label">Points Detected</div>
                </div>
                <div class="stat-card">
                    <div class="value" id="minValue">-</div>
                    <div class="label">Min Value</div>
                </div>
                <div class="stat-card">
                    <div class="value" id="maxValue">-</div>
                    <div class="label">Max Value</div>
                </div>
                <div class="stat-card">
                    <div class="value" id="avgValue">-</div>
                    <div class="label">Average</div>
                </div>
            </div>

            <div class="canvas-wrapper">
                <h3>Digitized Data</h3>
                <canvas id="digitizedCanvas"></canvas>
            </div>
            
            <div class="manual-points" id="manualPointsList" style="display: none;">
                <h4>Manual Points:</h4>
                <div id="manualPointsContent"></div>
            </div>
        </div>

        <!-- Step 4: Export -->
        <div id="export-tab" class="tab-content">
            <div class="info-box">
                <strong>üíæ Step 4: Export Your Data</strong><br>
                Review the extracted data and export in your preferred format.
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Export Format:</label>
                    <select id="exportFormat">
                        <option value="csv">CSV</option>
                        <option value="json">JSON</option>
                        <option value="tsv">TSV</option>
                        <option value="r">R Script</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label>Filename:</label>
                    <input type="text" id="filename" value="digitized_data" style="width: 200px;">
                </div>
                
                <div class="control-group">
                    <button onclick="exportData()" class="success">Export Data</button>
                    <button onclick="copyToClipboard()" class="secondary">Copy to Clipboard</button>
                </div>
            </div>
            
            <h3>Data Preview:</h3>
            <div class="data-preview" id="dataPreview">
                No data to display. Please complete digitization first.
            </div>
        </div>

        <div id="status" class="status"></div>
    </div>

    <script>
        let originalImageData = null;
        let cleanedImageData = null;
        let digitizedPoints = [];
        let manualPoints = [];
        let calibration = {
            yMin: -50,
            yMax: 210,
            startDate: new Date('2019-01-01'),
            endDate: new Date('2024-12-31'),
            interval: 'week'
        };
        let isPickingColor = false;

        // Tab switching
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName + '-tab').classList.add('active');
        }

        // Event listeners
        document.getElementById('fileInput').addEventListener('change', handleFileUpload);
        document.getElementById('targetColor').addEventListener('change', e => {
            document.getElementById('colorHex').value = e.target.value;
            if (originalImageData) processNoise();
        });
        document.getElementById('colorHex').addEventListener('input', e => {
            if (/^#[0-9A-Fa-f]{6}$/.test(e.target.value)) {
                document.getElementById('targetColor').value = e.target.value;
                if (originalImageData) processNoise();
            }
        });
        document.getElementById('tolerance').addEventListener('input', e => {
            document.getElementById('toleranceValue').textContent = e.target.value;
            if (originalImageData) processNoise();
        });
        document.getElementById('minCluster').addEventListener('input', e => {
            document.getElementById('minClusterValue').textContent = e.target.value;
            if (originalImageData) processNoise();
        });
        document.getElementById('smoothing').addEventListener('input', e => {
            document.getElementById('smoothingValue').textContent = e.target.value;
        });
        document.getElementById('digitizedCanvas').addEventListener('click', handleCanvasClick);
        document.getElementById('manualMode').addEventListener('change', e => {
            document.getElementById('manualPointsList').style.display = e.target.checked ? 'block' : 'none';
        });

        function handleFileUpload(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        displayOriginal(img);
                        processNoise();
                        showStatus('Image loaded successfully!', 'success');
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        }

        function displayOriginal(img) {
            const canvas = document.getElementById('originalCanvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        }

        function hexToRgb(hex) {
            hex = hex.replace('#', '');
            if (hex.length === 3) {
                hex = hex.split('').map(char => char + char).join('');
            }
            return {
                r: parseInt(hex.substr(0, 2), 16),
                g: parseInt(hex.substr(2, 2), 16),
                b: parseInt(hex.substr(4, 2), 16)
            };
        }

        function pickColor() {
            if (!originalImageData) {
                showStatus('Please load an image first!', 'error');
                return;
            }
            
            isPickingColor = true;
            showStatus('Click on the data line to pick its color', 'info');
            
            const canvas = document.getElementById('originalCanvas');
            canvas.style.cursor = 'crosshair';
            
            canvas.onclick = function(e) {
                if (!isPickingColor) return;
                
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) * (canvas.width / rect.width));
                const y = Math.floor((e.clientY - rect.top) * (canvas.height / rect.height));
                
                const ctx = canvas.getContext('2d');
                const pixel = ctx.getImageData(x, y, 1, 1).data;
                
                const hex = '#' + [pixel[0], pixel[1], pixel[2]].map(x => {
                    const h = x.toString(16);
                    return h.length === 1 ? '0' + h : h;
                }).join('');
                
                document.getElementById('targetColor').value = hex;
                document.getElementById('colorHex').value = hex;
                
                isPickingColor = false;
                canvas.style.cursor = 'default';
                canvas.onclick = null;
                
                showStatus(`Color picked: ${hex}`, 'success');
                processNoise();
            };
        }

        function processNoise() {
            if (!originalImageData) return;
            
            const tolerance = parseFloat(document.getElementById('tolerance').value);
            const minClusterSize = parseInt(document.getElementById('minCluster').value);
            const targetHex = document.getElementById('colorHex').value;
            const targetColor = hexToRgb(targetHex);
            
            const canvas = document.getElementById('cleanedCanvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = originalImageData.width;
            canvas.height = originalImageData.height;
            
            const imageData = new ImageData(
                new Uint8ClampedArray(originalImageData.data),
                originalImageData.width,
                originalImageData.height
            );
            
            const data = imageData.data;
            let kept = 0, removed = 0;
            
            // Remove non-matching pixels
            for (let i = 0; i < data.length; i += 4) {
                const dr = Math.abs(data[i] - targetColor.r);
                const dg = Math.abs(data[i + 1] - targetColor.g);
                const db = Math.abs(data[i + 2] - targetColor.b);
                const distance = Math.sqrt(dr*dr + dg*dg + db*db);
                
                if (distance > tolerance * 2.55) {
                    data[i] = data[i + 1] = data[i + 2] = data[i + 3] = 255;
                    removed++;
                } else {
                    kept++;
                }
            }
            
            // Remove isolated pixels (simplified version)
            if (minClusterSize > 1) {
                const width = canvas.width;
                const height = canvas.height;
                const output = new Uint8ClampedArray(data);
                
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const idx = (y * width + x) * 4;
                        if (data[idx] !== 255) {
                            let neighbors = 0;
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    if (dx === 0 && dy === 0) continue;
                                    const nIdx = ((y + dy) * width + (x + dx)) * 4;
                                    if (data[nIdx] !== 255) neighbors++;
                                }
                            }
                            if (neighbors < minClusterSize) {
                                output[idx] = output[idx + 1] = output[idx + 2] = output[idx + 3] = 255;
                            }
                        }
                    }
                }
                imageData.data.set(output);
            }
            
            ctx.putImageData(imageData, 0, 0);
            cleanedImageData = imageData;
            
            showStatus(`Noise removed! Kept ${kept} pixels, removed ${removed} pixels.`, 'success');
        }

        function resetNoise() {
            if (originalImageData) {
                const canvas = document.getElementById('cleanedCanvas');
                const ctx = canvas.getContext('2d');
                ctx.putImageData(originalImageData, 0, 0);
                cleanedImageData = originalImageData;
                showStatus('Reset to original image', 'info');
            }
        }

        function applyCalibration() {
            calibration.yMin = parseFloat(document.getElementById('yMin').value);
            calibration.yMax = parseFloat(document.getElementById('yMax').value);
            calibration.startDate = new Date(document.getElementById('startDate').value);
            calibration.endDate = new Date(document.getElementById('endDate').value);
            calibration.interval = document.getElementById('interval').value;
            
            showStatus('Calibration applied successfully!', 'success');
            
            // Auto-switch to digitization tab
            document.querySelectorAll('.tab')[2].click();
        }

        function digitizeData() {
            if (!cleanedImageData) {
                showStatus('Please remove noise first!', 'error');
                return;
            }
            
            const canvas = document.getElementById('digitizedCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = cleanedImageData.width;
            canvas.height = cleanedImageData.height;
            
            // Copy cleaned image
            ctx.putImageData(cleanedImageData, 0, 0);
            
            const width = canvas.width;
            const height = canvas.height;
            const data = cleanedImageData.data;
            
            digitizedPoints = [];
            
            // Generate time points
            const msPerDay = 24 * 60 * 60 * 1000;
            let timePoints = [];
            let current = new Date(calibration.startDate);
            
            while (current <= calibration.endDate) {
                timePoints.push(new Date(current));
                if (calibration.interval === 'day') {
                    current.setDate(current.getDate() + 1);
                } else if (calibration.interval === 'week') {
                    current.setDate(current.getDate() + 7);
                } else {
                    current.setMonth(current.getMonth() + 1);
                }
            }
            
            // Extract points
            const smoothing = parseInt(document.getElementById('smoothing').value);
            
            for (let i = 0; i < timePoints.length; i++) {
                const x = Math.floor(i * width / timePoints.length);
                
                // Find data point in column
                let ySum = 0, yCount = 0;
                
                for (let y = 0; y < height; y++) {
                    const idx = (y * width + x) * 4;
                    if (data[idx] !== 255 || data[idx + 1] !== 255 || data[idx + 2] !== 255) {
                        ySum += y;
                        yCount++;
                    }
                }
                
                if (yCount > 0) {
                    const yAvg = ySum / yCount;
                    const yNorm = 1 - (yAvg / height);
                    const value = calibration.yMin + yNorm * (calibration.yMax - calibration.yMin);
                    
                    digitizedPoints.push({
                        date: timePoints[i],
                        value: value,
                        x: x,
                        y: yAvg
                    });
                }
            }
            
            // Apply smoothing
            if (smoothing > 0 && digitizedPoints.length > smoothing) {
                for (let i = smoothing; i < digitizedPoints.length - smoothing; i++) {
                    let sum = 0;
                    for (let j = -smoothing; j <= smoothing; j++) {
                        sum += digitizedPoints[i + j].value;
                    }
                    digitizedPoints[i].value = sum / (smoothing * 2 + 1);
                }
            }
            
            // Draw points
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            digitizedPoints.forEach((point, i) => {
                if (i === 0) ctx.moveTo(point.x, point.y);
                else ctx.lineTo(point.x, point.y);
            });
            ctx.stroke();
            
            // Draw points
            ctx.fillStyle = '#00ff00';
            digitizedPoints.forEach(point => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
            
            updateStats();
            updateDataPreview();
            showStatus(`Digitized ${digitizedPoints.length} points successfully!`, 'success');
        }

        function handleCanvasClick(e) {
            if (!document.getElementById('manualMode').checked) return;
            
            const canvas = document.getElementById('digitizedCanvas');
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);
            
            // Convert to data coordinates
            const xNorm = x / canvas.width;
            const yNorm = 1 - (y / canvas.height);
            
            const totalDays = (calibration.endDate - calibration.startDate) / (24 * 60 * 60 * 1000);
            const date = new Date(calibration.startDate.getTime() + totalDays * xNorm * 24 * 60 * 60 * 1000);
            const value = calibration.yMin + yNorm * (calibration.yMax - calibration.yMin);
            
            const point = { date, value, x, y };
            manualPoints.push(point);
            
            // Redraw
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, Math.PI * 2);
            ctx.fill();
            
            updateManualPointsList();
            showStatus(`Manual point added: ${date.toLocaleDateString()} = ${value.toFixed(2)}`, 'info');
        }

        function updateManualPointsList() {
            const content = document.getElementById('manualPointsContent');
            content.innerHTML = manualPoints.map((point, index) => `
                <div class="manual-point">
                    <span>${point.date.toLocaleDateString()}: ${point.value.toFixed(2)}</span>
                    <span class="remove-point" onclick="removeManualPoint(${index})">√ó</span>
                </div>
            `).join('');
        }

        function removeManualPoint(index) {
            manualPoints.splice(index, 1);
            updateManualPointsList();
            // Redraw canvas
            if (cleanedImageData) {
                digitizeData();
            }
        }

        function clearPoints() {
            digitizedPoints = [];
            manualPoints = [];
            if (cleanedImageData) {
                const canvas = document.getElementById('digitizedCanvas');
                const ctx = canvas.getContext('2d');
                ctx.putImageData(cleanedImageData, 0, 0);
            }
            updateStats();
            updateDataPreview();
            showStatus('All points cleared', 'info');
        }

        function interpolateGaps() {
            if (digitizedPoints.length < 2) {
                showStatus('Need at least 2 points to interpolate', 'error');
                return;
            }
            
            // Find gaps and interpolate
            const filled = [];
            for (let i = 0; i < digitizedPoints.length - 1; i++) {
                filled.push(digitizedPoints[i]);
                
                const gap = digitizedPoints[i + 1].x - digitizedPoints[i].x;
                if (gap > 10) { // If gap is large
                    const steps = Math.floor(gap / 5);
                    for (let j = 1; j < steps; j++) {
                        const ratio = j / steps;
                        const x = digitizedPoints[i].x + ratio * (digitizedPoints[i + 1].x - digitizedPoints[i].x);
                        const y = digitizedPoints[i].y + ratio * (digitizedPoints[i + 1].y - digitizedPoints[i].y);
                        const value = digitizedPoints[i].value + ratio * (digitizedPoints[i + 1].value - digitizedPoints[i].value);
                        const date = new Date(digitizedPoints[i].date.getTime() + 
                            ratio * (digitizedPoints[i + 1].date - digitizedPoints[i].date));
                        
                        filled.push({ date, value, x, y });
                    }
                }
            }
            filled.push(digitizedPoints[digitizedPoints.length - 1]);
            
            digitizedPoints = filled;
            
            // Redraw
            const canvas = document.getElementById('digitizedCanvas');
            const ctx = canvas.getContext('2d');
            
            if (cleanedImageData) {
                ctx.putImageData(cleanedImageData, 0, 0);
            }
            
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            digitizedPoints.forEach((point, i) => {
                if (i === 0) ctx.moveTo(point.x, point.y);
                else ctx.lineTo(point.x, point.y);
            });
            ctx.stroke();
            
            ctx.fillStyle = '#00ff00';
            digitizedPoints.forEach(point => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 2, 0, Math.PI * 2);
                ctx.fill();
            });
            
            updateStats();
            updateDataPreview();
            showStatus(`Interpolated gaps - now ${digitizedPoints.length} points`, 'success');
        }

        function updateStats() {
            const allPoints = [...digitizedPoints, ...manualPoints];
            
            document.getElementById('pointCount').textContent = allPoints.length;
            
            if (allPoints.length > 0) {
                const values = allPoints.map(p => p.value);
                document.getElementById('minValue').textContent = Math.min(...values).toFixed(2);
                document.getElementById('maxValue').textContent = Math.max(...values).toFixed(2);
                document.getElementById('avgValue').textContent = (values.reduce((a, b) => a + b, 0) / values.length).toFixed(2);
            } else {
                document.getElementById('minValue').textContent = '-';
                document.getElementById('maxValue').textContent = '-';
                document.getElementById('avgValue').textContent = '-';
            }
        }

        function updateDataPreview() {
            const allPoints = [...digitizedPoints, ...manualPoints].sort((a, b) => a.date - b.date);
            
            if (allPoints.length === 0) {
                document.getElementById('dataPreview').textContent = 'No data points digitized yet.';
                return;
            }
            
            const format = document.getElementById('exportFormat')?.value || 'csv';
            let preview = '';
            
            if (format === 'csv') {
                preview = 'Date,Value\n';
                allPoints.forEach(p => {
                    preview += `${p.date.toISOString().split('T')[0]},${p.value.toFixed(3)}\n`;
                });
            } else if (format === 'json') {
                const data = allPoints.map(p => ({
                    date: p.date.toISOString().split('T')[0],
                    value: parseFloat(p.value.toFixed(3))
                }));
                preview = JSON.stringify(data, null, 2);
            } else if (format === 'tsv') {
                preview = 'Date\tValue\n';
                allPoints.forEach(p => {
                    preview += `${p.date.toISOString().split('T')[0]}\t${p.value.toFixed(3)}\n`;
                });
            } else if (format === 'r') {
                preview = '# R Script for digitized data\n';
                preview += 'data <- data.frame(\n';
                preview += '  date = as.Date(c(\n';
                preview += allPoints.map(p => `    "${p.date.toISOString().split('T')[0]}"`).join(',\n');
                preview += '\n  )),\n';
                preview += '  value = c(\n';
                preview += allPoints.map(p => `    ${p.value.toFixed(3)}`).join(',\n');
                preview += '\n  )\n)\n';
            }
            
            document.getElementById('dataPreview').textContent = preview;
        }

        function exportData() {
            const allPoints = [...digitizedPoints, ...manualPoints].sort((a, b) => a.date - b.date);
            
            if (allPoints.length === 0) {
                showStatus('No data to export!', 'error');
                return;
            }
            
            const format = document.getElementById('exportFormat').value;
            const filename = document.getElementById('filename').value || 'digitized_data';
            
            let content = '';
            let mimeType = 'text/plain';
            let extension = '.txt';
            
            if (format === 'csv') {
                content = 'Date,Value\n';
                allPoints.forEach(p => {
                    content += `${p.date.toISOString().split('T')[0]},${p.value.toFixed(3)}\n`;
                });
                mimeType = 'text/csv';
                extension = '.csv';
            } else if (format === 'json') {
                const data = allPoints.map(p => ({
                    date: p.date.toISOString().split('T')[0],
                    value: parseFloat(p.value.toFixed(3))
                }));
                content = JSON.stringify(data, null, 2);
                mimeType = 'application/json';
                extension = '.json';
            } else if (format === 'tsv') {
                content = 'Date\tValue\n';
                allPoints.forEach(p => {
                    content += `${p.date.toISOString().split('T')[0]}\t${p.value.toFixed(3)}\n`;
                });
                mimeType = 'text/tab-separated-values';
                extension = '.tsv';
            } else if (format === 'r') {
                content = '# R Script for digitized data\n';
                content += '# Generated on ' + new Date().toISOString() + '\n\n';
                content += 'data <- data.frame(\n';
                content += '  date = as.Date(c(\n';
                content += allPoints.map(p => `    "${p.date.toISOString().split('T')[0]}"`).join(',\n');
                content += '\n  )),\n';
                content += '  value = c(\n';
                content += allPoints.map(p => `    ${p.value.toFixed(3)}`).join(',\n');
                content += '\n  )\n)\n\n';
                content += '# Plot the data\n';
                content += 'plot(data$date, data$value, type="l", col="blue",\n';
                content += '     xlab="Date", ylab="Value", main="Digitized Data")\n';
                content += 'points(data$date, data$value, pch=16, cex=0.5, col="blue")\n';
                extension = '.R';
            }
            
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename + extension;
            a.click();
            URL.revokeObjectURL(url);
            
            showStatus(`Data exported as ${filename}${extension}`, 'success');
        }

        function copyToClipboard() {
            const preview = document.getElementById('dataPreview').textContent;
            
            if (preview === 'No data points digitized yet.' || preview === 'No data to display. Please complete digitization first.') {
                showStatus('No data to copy!', 'error');
                return;
            }
            
            navigator.clipboard.writeText(preview).then(() => {
                showStatus('Data copied to clipboard!', 'success');
            }).catch(err => {
                showStatus('Failed to copy to clipboard', 'error');
            });
        }

        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = 'status ' + type;
            setTimeout(() => {
                status.className = 'status';
                status.style.display = 'none';
            }, 3000);
        }

        // Initialize with URL parameters if present
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.has('color')) {
            const color = urlParams.get('color');
            document.getElementById('targetColor').value = color;
            document.getElementById('colorHex').value = color;
        }
        if (urlParams.has('ymin')) {
            document.getElementById('yMin').value = urlParams.get('ymin');
        }
        if (urlParams.has('ymax')) {
            document.getElementById('yMax').value = urlParams.get('ymax');
        }
        if (urlParams.has('startdate')) {
            document.getElementById('startDate').value = urlParams.get('startdate');
        }
        if (urlParams.has('enddate')) {
            document.getElementById('endDate').value = urlParams.get('enddate');
        }
    </script>
</body>
</html>